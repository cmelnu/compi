VHDL Code Generator
===================

Overview
--------

The VHDL code generator is the final phase of the compiler. It traverses the AST and emits synthesizable VHDL code that implements the C program's behavior in hardware. The generator is implemented in ``src/codegen/codegen_vhdl.c``.

**Key responsibilities:**

* Convert C functions to VHDL entities with synchronous processes
* Map C types to VHDL types (``int`` → ``std_logic_vector(31 downto 0)``)
* Translate C operators to VHDL equivalents (``==`` → ``=``, ``!=`` → ``/=``)
* Generate VHDL records for C structs
* Handle arrays with VHDL array types
* Convert control flow to VHDL constructs (``if``/``elsif``/``else``, ``while`` loops, ``for`` loops rewritten as ``while``)
* Emit signals for local variables
* Generate proper VHDL signal assignments with type conversions

Location
--------

- Source file: ``src/codegen/codegen_vhdl.c``
- Header file: ``include/codegen_vhdl.h``

Code Generation Entry Point
----------------------------

generate_vhdl()
~~~~~~~~~~~~~~~

.. code-block:: c

   void generate_vhdl(ASTNode *root, FILE *out);

The public API function that initiates VHDL generation. It delegates to the internal dispatcher ``gen_node()``:

.. code-block:: c

   void generate_vhdl(ASTNode *root, FILE *out) {
       gen_node(root, out);
   }

**Parameters:**

* ``root``: AST root node (typically ``NODE_PROGRAM``)
* ``out``: Output file stream for VHDL code

Node Dispatcher
---------------

gen_node()
~~~~~~~~~~

Internal function that dispatches to specialized generators based on node type:

.. code-block:: c

   static void gen_node(ASTNode *node, FILE *out) {
       if (!node) return;
       
       switch (node->type) {
           case NODE_PROGRAM:          gen_program(node, out); break;
           case NODE_FUNCTION_DECL:    gen_function(node, out); break;
           case NODE_STATEMENT:        gen_statement(node, out); break;
           case NODE_WHILE_STATEMENT:  gen_while(node, out); break;
           case NODE_FOR_STATEMENT:    gen_for(node, out); break;
           case NODE_IF_STATEMENT:     gen_if(node, out); break;
           case NODE_BREAK_STATEMENT:  gen_break(node, out); break;
           case NODE_CONTINUE_STATEMENT: gen_continue(node, out); break;
           case NODE_BINARY_EXPR:      gen_binary_expr(node, out); break;
           case NODE_BINARY_OP:        gen_unary_op(node, out); break;
           case NODE_EXPRESSION:       gen_expression(node, out); break;
           default: /* intentionally ignored */ break;
       }
   }

**Design:** Uses switch statement for efficient dispatch. Ignores node types that don't directly produce VHDL output (e.g., ``NODE_VAR_DECL`` is handled within statement generation).

Program Generation
------------------

gen_program()
~~~~~~~~~~~~~

Generates VHDL preamble and processes all top-level functions:

.. code-block:: c

   static void gen_program(ASTNode *node, FILE *out) {
       // Emit VHDL header
       fprintf(out, "-- VHDL generated by compi (readable variant)\n\n");
       fprintf(out, "library IEEE;\n");
       fprintf(out, "use IEEE.STD_LOGIC_1164.ALL;\n");
       fprintf(out, "use IEEE.NUMERIC_STD.ALL;\n\n");
       
       // Emit struct type declarations
       emit_struct_declarations(out);
       
       // Generate each function
       for (int i = 0; i < node->num_children; ++i) {
           gen_node(node->children[i], out);
       }
   }

**Output structure:**

1. Comment header identifying compi-generated code
2. IEEE library imports (``STD_LOGIC_1164``, ``NUMERIC_STD``)
3. VHDL record type definitions for C structs
4. Entity and architecture for each C function

**Example output:**

.. code-block:: vhdl

   -- VHDL generated by compi (readable variant)
   
   library IEEE;
   use IEEE.STD_LOGIC_1164.ALL;
   use IEEE.NUMERIC_STD.ALL;
   
   -- Struct Point as VHDL record
   type Point_t is record
     x : std_logic_vector(31 downto 0);
     y : std_logic_vector(31 downto 0);
   end record;

Function Generation
-------------------

gen_function()
~~~~~~~~~~~~~~

Converts C function to VHDL entity + architecture:

.. code-block:: c

   static void gen_function(ASTNode *node, FILE *out) {
       const char *fname = node->value;
       
       // Collect parameters (NODE_VAR_DECL children)
       ASTNode *params[128] = {0};
       int pcount = 0;
       for (int i = 0; i < node->num_children; ++i) {
           if (node->children[i]->type == NODE_VAR_DECL) {
               params[pcount++] = node->children[i];
           }
       }
       
       // ENTITY DECLARATION
       fprintf(out, "-- Function: %s\n", fname);
       fprintf(out, "entity %s is\n", fname);
       fprintf(out, "  port (\n");
       fprintf(out, "    clk   : in  std_logic;\n");
       fprintf(out, "    reset : in  std_logic;\n");
       
       // Input ports for parameters
       for (int i = 0; i < pcount; ++i) {
           ASTNode *p = params[i];
           int is_struct = find_struct_index(p->token.value) >= 0;
           if (is_struct) {
               fprintf(out, "    %s : in %s_t;\n", p->value, p->token.value);
           } else {
               fprintf(out, "    %s : in %s;\n", p->value, ctype_to_vhdl(p->token.value));
           }
       }
       
       // Output port for return value
       if (find_struct_index(node->token.value) >= 0) {
           fprintf(out, "    result : out %s_t\n", node->token.value);
       } else {
           fprintf(out, "    result : out %s\n", ctype_to_vhdl(node->token.value));
       }
       
       fprintf(out, "  );\nend entity;\n\n");
       
       // ARCHITECTURE
       fprintf(out, "architecture behavioral of %s is\n", fname);
       emit_local_signals(node, out);  // Local variable signals
       fprintf(out, "begin\n");
       fprintf(out, "  process(clk, reset)\n");
       fprintf(out, "  begin\n");
       fprintf(out, "    if reset = '1' then\n");
       fprintf(out, "      -- Reset logic (user-defined)\n");
       fprintf(out, "    elsif rising_edge(clk) then\n");
       
       // Function body
       for (int i = 0; i < node->num_children; ++i) {
           if (node->children[i]->type == NODE_STATEMENT) {
               gen_node(node->children[i], out);
           }
       }
       
       fprintf(out, "    end if;\n");
       fprintf(out, "  end process;\n");
       fprintf(out, "end architecture;\n\n");
   }

**C to VHDL mapping:**

====================== ================================
C construct            VHDL equivalent
====================== ================================
Function declaration   Entity + Architecture
Function parameters    Entity input ports
Return value           Entity output port ``result``
Local variables        Signals declared in architecture
Function body          Synchronous process (clocked)
====================== ================================

**Example:**

C code:

.. code-block:: c

   int add(int a, int b) {
       return a + b;
   }

Generated VHDL:

.. code-block:: vhdl

   -- Function: add
   entity add is
     port (
       clk   : in  std_logic;
       reset : in  std_logic;
       a : in std_logic_vector(31 downto 0);
       b : in std_logic_vector(31 downto 0);
       result : out std_logic_vector(31 downto 0)
     );
   end entity;
   
   architecture behavioral of add is
   begin
     process(clk, reset)
     begin
       if reset = '1' then
         -- Reset logic
       elsif rising_edge(clk) then
         result <= unsigned(a) + unsigned(b);
       end if;
     end process;
   end architecture;

Type Conversion
---------------

ctype_to_vhdl()
~~~~~~~~~~~~~~~

Maps C types to VHDL types (defined in ``src/core/utils.c``):

.. code-block:: c

   char* ctype_to_vhdl(const char* ctype) {
       if (strcmp(ctype, "int") == 0) {
           return "std_logic_vector(31 downto 0)";
       } else if (strcmp(ctype, "float") == 0) {
           return "std_logic_vector(31 downto 0)";
       } else if (strcmp(ctype, "double") == 0) {
           return "std_logic_vector(63 downto 0)";
       } else if (strcmp(ctype, "char") == 0) {
           return "std_logic_vector(7 downto 0)";
       }
       return "std_logic_vector(31 downto 0)";  // Default
   }

**Type mapping table:**

============= ================================
C type        VHDL type
============= ================================
``int``       ``std_logic_vector(31 downto 0)``
``float``     ``std_logic_vector(31 downto 0)``
``double``    ``std_logic_vector(63 downto 0)``
``char``      ``std_logic_vector(7 downto 0)``
``struct X``  ``X_t`` (VHDL record type)
============= ================================

.. note::
   Floating-point types (``float``, ``double``) are mapped to ``std_logic_vector`` for bit manipulation, not true floating-point VHDL types.

Statement Generation
--------------------

gen_statement()
~~~~~~~~~~~~~~~

Processes statement nodes and delegates to specific handlers:

.. code-block:: c

   static void gen_statement(ASTNode *node, FILE *out) {
       for (int i = 0; i < node->num_children; ++i) {
           ASTNode *child = node->children[i];
           
           switch (child->type) {
               case NODE_VAR_DECL:
                   // Handle variable declarations with initialization
                   // ...struct init or array init or simple init
                   break;
               
               case NODE_ASSIGNMENT:
                   emit_assignment(child, out, "      ");
                   break;
               
               case NODE_IF_STATEMENT:
               case NODE_WHILE_STATEMENT:
               case NODE_FOR_STATEMENT:
               case NODE_BREAK_STATEMENT:
               case NODE_CONTINUE_STATEMENT:
                   gen_node(child, out);
                   break;
               
               case NODE_EXPRESSION:
               case NODE_BINARY_EXPR:
                   // Return statement or standalone expression
                   fprintf(out, "      result <= ");
                   gen_node(child, out);
                   fprintf(out, ";\n");
                   break;
           }
       }
   }

**Variable initialization handling:**

For struct initialization:

.. code-block:: c

   if (init && init->value && strcmp(init->value, "struct_init") == 0) {
       // Initialize each struct field
       for (int f = 0; f < g_structs[struct_idx].field_count; ++f) {
           const char *field = g_structs[struct_idx].fields[f].field_name;
           const char *val = (f < init->num_children) ? init->children[f]->value : "0";
           fprintf(out, "      %s.%s <= to_unsigned(%s, 32);\n", 
                   child->value, field, val);
       }
   }

Control Flow Generation
-----------------------

If Statements
~~~~~~~~~~~~~

.. code-block:: c

   static void gen_if(ASTNode *node, FILE *out) {
       ASTNode *cond = node->children[0];
       
       fprintf(out, "      if ");
       emit_condition(cond, out);
       fprintf(out, " then\n");
       
       // Process if body and else-if/else clauses
       for (int j = 1; j < node->num_children; ++j) {
           ASTNode *branch = node->children[j];
           if (branch->type == NODE_ELSE_IF_STATEMENT) {
               ASTNode *elseif_cond = branch->children[0];
               fprintf(out, "      elsif ");
               emit_condition(elseif_cond, out);
               fprintf(out, " then\n");
               for (int k = 1; k < branch->num_children; ++k) {
                   gen_node(branch->children[k], out);
               }
           } else if (branch->type == NODE_ELSE_STATEMENT) {
               fprintf(out, "      else\n");
               for (int k = 0; k < branch->num_children; ++k) {
                   gen_node(branch->children[k], out);
               }
           } else {
               gen_node(branch, out);
           }
       }
       fprintf(out, "      end if;\n");
   }

**C to VHDL mapping:**

.. code-block:: c

   if (x > 0) {
       y = 1;
   } else if (x < 0) {
       y = -1;
   } else {
       y = 0;
   }

↓

.. code-block:: vhdl

   if unsigned(x) > to_unsigned(0, 32) then
     y <= to_unsigned(1, 32);
   elsif unsigned(x) < to_unsigned(0, 32) then
     y <= to_signed(-1, 32);
   else
     y <= to_unsigned(0, 32);
   end if;

While Loops
~~~~~~~~~~~

.. code-block:: c

   static void gen_while(ASTNode *node, FILE *out) {
       ASTNode *cond = node->children[0];
       
       fprintf(out, "      while ");
       emit_condition(cond, out);
       fprintf(out, " loop\n");
       
       for (int j = 1; j < node->num_children; ++j) {
           gen_node(node->children[j], out);
       }
       
       fprintf(out, "      end loop;\n");
   }

**Example:**

C code:

.. code-block:: c

   while (i < 10) {
       sum = sum + i;
       i = i + 1;
   }

VHDL output:

.. code-block:: vhdl

   while unsigned(i) < to_unsigned(10, 32) loop
     sum <= unsigned(sum) + unsigned(i);
     i <= unsigned(i) + to_unsigned(1, 32);
   end loop;

For Loops (Converted to While)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

For loops are rewritten as while loops with initialization and increment:

.. code-block:: c

   static void gen_for(ASTNode *node, FILE *out) {
       // Extract init, condition, increment from for loop children
       int cond_index = 0;
       ASTNode *first = node->children[0];
       
       // Check if first child is init statement (var decl or assignment)
       if (first->type == NODE_ASSIGNMENT || first->type == NODE_VAR_DECL) {
           emit_assignment(first, out, "      ");  // or emit_initializer
           cond_index = 1;
       }
       
       ASTNode *cond = node->children[cond_index];
       
       // Find increment (last child, if it's an assignment)
       int incr_index = node->num_children - 1;
       ASTNode *incr = NULL;
       if (node->children[incr_index]->type == NODE_ASSIGNMENT) {
           incr = node->children[incr_index];
       }
       
       // Emit while loop
       fprintf(out, "      while ");
       emit_condition(cond, out);
       fprintf(out, " loop\n");
       
       // Loop body (skip initialization and increment)
       for (int j = cond_index + 1; j < node->num_children; ++j) {
           if (j == incr_index) continue;  // Skip increment here
           gen_node(node->children[j], out);
       }
       
       // Emit increment at end of loop body
       if (incr) {
           emit_assignment(incr, out, "        ");
       }
       
       fprintf(out, "      end loop;\n");
   }

**Example transformation:**

C code:

.. code-block:: c

   for (int i = 0; i < 10; i++) {
       sum = sum + i;
   }

VHDL output:

.. code-block:: vhdl

   i <= to_unsigned(0, 32);
   while unsigned(i) < to_unsigned(10, 32) loop
     sum <= unsigned(sum) + unsigned(i);
     i <= unsigned(i) + to_unsigned(1, 32);
   end loop;

Break and Continue
~~~~~~~~~~~~~~~~~~

.. code-block:: c

   static void gen_break(ASTNode *node, FILE *out) { 
       fprintf(out, "      exit;\n"); 
   }
   
   static void gen_continue(ASTNode *node, FILE *out) { 
       fprintf(out, "      next;\n"); 
   }

**Mapping:**

* C ``break`` → VHDL ``exit``
* C ``continue`` → VHDL ``next``

Expression Generation
---------------------

Binary Expressions
~~~~~~~~~~~~~~~~~~

.. code-block:: c

   static void gen_binary_expr(ASTNode *node, FILE *out) {
       const char *op = node->value;
       ASTNode *left = node->children[0];
       ASTNode *right = node->children[1];
       
       // Normalize operators
       if (strcmp(op, "==") == 0) op = "=";
       else if (strcmp(op, "!=") == 0) op = "/=";
       
       // Handle logical short-circuit operators
       if (strcmp(node->value, "&&") == 0 || strcmp(node->value, "||") == 0) {
           emit_boolean_gate(left, right, 
               strcmp(node->value, "&&") == 0 ? " and " : " or ", out);
           return;
       }
       
       // Comparison operators (produce boolean results)
       if (strcmp(op, "=") == 0 || strcmp(op, "/=") == 0 || 
           strcmp(op, "<") == 0 || strcmp(op, "<=") == 0 ||
           strcmp(op, ">") == 0 || strcmp(op, ">=") == 0) {
           // Convert both sides to unsigned for comparison
           fprintf(out, "unsigned(");
           gen_node(left, out);
           fprintf(out, ") %s unsigned(", op);
           gen_node(right, out);
           fprintf(out, ")");
           return;
       }
       
       // Bitwise operators
       if (strcmp(op, "&") == 0) {
           fprintf(out, "unsigned(");
           gen_node(left, out);
           fprintf(out, ") and unsigned(");
           gen_node(right, out);
           fprintf(out, ")");
           return;
       }
       if (strcmp(op, "|") == 0) {
           fprintf(out, "unsigned(");
           gen_node(left, out);
           fprintf(out, ") or unsigned(");
           gen_node(right, out);
           fprintf(out, ")");
           return;
       }
       if (strcmp(op, "^") == 0) {
           fprintf(out, "unsigned(");
           gen_node(left, out);
           fprintf(out, ") xor unsigned(");
           gen_node(right, out);
           fprintf(out, ")");
           return;
       }
       
       // Shift operators
       if (strcmp(op, "<<") == 0) {
           fprintf(out, "shift_left(unsigned(");
           gen_node(left, out);
           fprintf(out, "), to_integer(unsigned(");
           gen_node(right, out);
           fprintf(out, "))))");
           return;
       }
       if (strcmp(op, ">>") == 0) {
           fprintf(out, "shift_right(unsigned(");
           gen_node(left, out);
           fprintf(out, "), to_integer(unsigned(");
           gen_node(right, out);
           fprintf(out, "))))");
           return;
       }
       
       // Fallback: arithmetic operators
       gen_node(left, out);
       fprintf(out, " %s ", op);
       gen_node(right, out);
   }

**Operator translation table:**

=================== =================================
C operator          VHDL equivalent
=================== =================================
``==``              ``=``
``!=``              ``/=``
``<``, ``>``, etc.  Same (with ``unsigned()`` wrapping)
``&&``              ``and`` (boolean logic)
``||``              ``or`` (boolean logic)
``&``               ``and`` (bitwise)
``|``               ``or`` (bitwise)
``^``               ``xor`` (bitwise)
``<<``              ``shift_left(value, amount)``
``>>``              ``shift_right(value, amount)``
``+``, ``-``, etc.  Same (arithmetic)
=================== =================================

Primary Expressions
~~~~~~~~~~~~~~~~~~~

.. code-block:: c

   static void gen_expression(ASTNode *node, FILE *out) {
       if (!node->value) {
           fprintf(out, "unknown");
           return;
       }
       
       // Array element: arr[index]
       if (strchr(node->value, '[')) {
           emit_array_element(node->value, out);
           return;
       }
       
       // Negative literal: -42
       if (is_negative_literal(node->value)) {
           if (isalpha(node->value[1])) {
               fprintf(out, "-unsigned(%s)", node->value + 1);
           } else {
               fprintf(out, "to_signed(%s, 32)", node->value);
           }
           return;
       }
       
       // Struct field access: point__x → point.x
       if (strstr(node->value, "__")) {
           char buf[256];
           strncpy(buf, node->value, sizeof(buf) - 1);
           for (char *p = buf; *p; ++p) {
               if (*p == '_' && *(p + 1) == '_') {
                   *p = '.';
                   memmove(p + 1, p + 2, strlen(p + 2) + 1);
               }
           }
           fprintf(out, "%s", buf);
           return;
       }
       
       // Simple identifier or number
       fprintf(out, "%s", node->value);
   }

**Expression transformations:**

* ``arr[i]`` → ``arr(i)`` (VHDL array indexing uses parentheses)
* ``point__x`` → ``point.x`` (struct field access)
* ``-42`` → ``to_signed(-42, 32)`` (signed literal)
* ``-x`` → ``-unsigned(x)`` (negation of variable)

Unary Operators
~~~~~~~~~~~~~~~

.. code-block:: c

   static void gen_unary_op(ASTNode *node, FILE *out) {
       if (!node->value || node->num_children != 1) {
           fprintf(out, "-- unsupported unary op");
           return;
       }
       
       ASTNode *inner = node->children[0];
       
       if (strcmp(node->value, "!") == 0) {
           // Logical NOT
           if (node_is_boolean(inner)) {
               fprintf(out, "not (");
               gen_node(inner, out);
               fprintf(out, ")");
           } else {
               // Treat as C-style boolean (0 = false, non-zero = true)
               fprintf(out, "(unsigned(");
               gen_node(inner, out);
               fprintf(out, ") = 0)");
           }
       } else if (strcmp(node->value, "~") == 0) {
           // Bitwise NOT
           fprintf(out, "not unsigned(");
           gen_node(inner, out);
           fprintf(out, ")");
       }
   }

**Unary operator mapping:**

* ``!x`` → ``not (x)`` if ``x`` is boolean
* ``!x`` → ``(unsigned(x) = 0)`` if ``x`` is numeric (C-style boolean)
* ``~x`` → ``not unsigned(x)`` (bitwise NOT)

Helper Functions
----------------

emit_condition()
~~~~~~~~~~~~~~~~

Converts C condition expressions to VHDL boolean expressions:

.. code-block:: c

   static void emit_condition(ASTNode *cond, FILE *out) {
       if (!cond) {
           fprintf(out, "(false)");
           return;
       }
       
       if (cond->type == NODE_BINARY_EXPR) {
           if (is_bool_comparison(cond->value)) {
               // Already a boolean comparison
               gen_node(cond, out);
           } else {
               // Arithmetic expression used as condition: treat as "!= 0"
               fprintf(out, "unsigned(");
               gen_node(cond, out);
               fprintf(out, ") /= 0");
           }
       } else if (cond->type == NODE_EXPRESSION && cond->value) {
           // Simple identifier as condition
           fprintf(out, "unsigned(%s) /= 0", cond->value);
       } else {
           fprintf(out, "(%s)", cond->value ? cond->value : "false");
       }
   }

**Behavior:**

* Boolean comparisons (``x > 0``) → passed through unchanged
* Arithmetic expressions (``x + y``) → wrapped as ``unsigned(...) /= 0``
* Identifiers (``flag``) → converted to ``unsigned(flag) /= 0``

emit_array_element()
~~~~~~~~~~~~~~~~~~~~

Converts C array subscripting to VHDL array indexing:

.. code-block:: c

   static void emit_array_element(const char *value, FILE *out) {
       char arr_name[64] = {0};
       char arr_idx[64] = {0};
       
       const char *lbr = strchr(value, '[');
       if (!lbr) {
           fprintf(out, "%s", value);
           return;
       }
       
       // Extract array name and index
       int name_len = (int)(lbr - value);
       strncpy(arr_name, value, name_len);
       
       const char *idx_start = lbr + 1;
       const char *idx_end = strchr(idx_start, ']');
       if (idx_end && idx_end > idx_start) {
           strncpy(arr_idx, idx_start, idx_end - idx_start);
           fprintf(out, "%s(%s)", arr_name, arr_idx);  // VHDL uses parentheses
       } else {
           fprintf(out, "-- Invalid array index");
       }
   }

**Transformation:** ``arr[i]`` → ``arr(i)``

emit_assignment()
~~~~~~~~~~~~~~~~~

Generates VHDL signal assignments:

.. code-block:: c

   static void emit_assignment(ASTNode *assign, FILE *out, const char *indent) {
       if (!assign || assign->num_children != 2) return;
       
       ASTNode *lhs = assign->children[0];
       ASTNode *rhs = assign->children[1];
       
       fprintf(out, "%s", indent);
       
       // Handle array element assignment
       if (lhs->value && strchr(lhs->value, '[')) {
           // Parse arr[idx] → emit arr(idx) <= rhs;
           // ...
       } else {
           // Simple assignment
           fprintf(out, "%s <= ", lhs->value);
           gen_node(rhs, out);
           fprintf(out, ";\n");
       }
   }

**Output:** ``variable <= expression;`` with proper indentation

Struct Support
--------------

emit_struct_declarations()
~~~~~~~~~~~~~~~~~~~~~~~~~~

Generates VHDL record types for C structs:

.. code-block:: c

   static void emit_struct_declarations(FILE *out) {
       for (int s = 0; s < g_struct_count; ++s) {
           StructInfo *si = &g_structs[s];
           fprintf(out, "-- Struct %s as VHDL record\n", si->name);
           fprintf(out, "type %s_t is record\n", si->name);
           
           for (int f = 0; f < si->field_count; ++f) {
               fprintf(out, "  %s : %s;\n", 
                   si->fields[f].field_name,
                   ctype_to_vhdl(si->fields[f].field_type));
           }
           
           fprintf(out, "end record;\n\n");
       }
   }

**Example:**

C code:

.. code-block:: c

   struct Point {
       int x;
       int y;
   };

Generated VHDL:

.. code-block:: vhdl

   -- Struct Point as VHDL record
   type Point_t is record
     x : std_logic_vector(31 downto 0);
     y : std_logic_vector(31 downto 0);
   end record;

emit_local_signals()
~~~~~~~~~~~~~~~~~~~~

Declares VHDL signals for local variables:

.. code-block:: c

   static void emit_local_signals(ASTNode *function_decl, FILE *out) {
       // Traverse function body to find variable declarations
       for (int i = 0; i < function_decl->num_children; ++i) {
           ASTNode *child = function_decl->children[i];
           if (child->type != NODE_STATEMENT) continue;
           
           for (int j = 0; j < child->num_children; ++j) {
               ASTNode *stmt_child = child->children[j];
               
               if (stmt_child->type == NODE_VAR_DECL) {
                   // Check if it's a struct
                   if (find_struct_index(stmt_child->token.value) >= 0) {
                       fprintf(out, "  signal %s : %s_t;\n", 
                           stmt_child->value, stmt_child->token.value);
                       continue;
                   }
                   
                   // Check if it's an array
                   char *arr_bracket = strchr(stmt_child->value, '[');
                   if (arr_bracket) {
                       // Extract array name and size
                       // Generate: type arr_type is array (0 to size-1) of element_type;
                       // Generate: signal arr : arr_type;
                       // ...
                   } else {
                       // Scalar variable
                       fprintf(out, "  signal %s : %s;\n", 
                           stmt_child->value, 
                           ctype_to_vhdl(stmt_child->token.value));
                   }
               }
           }
       }
   }

**Output example:**

.. code-block:: vhdl

   signal x : std_logic_vector(31 downto 0);
   signal arr : arr_type;
   signal point : Point_t;

Array Support
-------------

Arrays are declared as constrained VHDL array types:

.. code-block:: c

   // For: int arr[10];
   fprintf(out, "  type arr_type is array (0 to 9) of std_logic_vector(31 downto 0);\n");
   fprintf(out, "  signal arr : arr_type;\n");

Array initialization:

.. code-block:: c

   // For: int arr[3] = {1, 2, 3};
   fprintf(out, "  constant arr_init : arr_type := (");
   for (int k = 0; k < init_list->num_children; ++k) {
       const char *val = init_list->children[k]->value;
       fprintf(out, "to_unsigned(%s, 32)%s", val, 
           (k < init_list->num_children - 1) ? ", " : "");
   }
   fprintf(out, ");\n");
   fprintf(out, "  signal arr : arr_type := arr_init;\n");

Symbol Table Integration
-------------------------

The code generator uses the global struct symbol table:

.. code-block:: c

   extern StructInfo g_structs[64];
   extern int g_struct_count;

**Functions:**

* ``find_struct_index(const char *name)`` - Lookup struct by name
* ``struct_field_type(const char *struct_name, const char *field_name)`` - Get field type

**StructInfo definition:**

.. code-block:: c

   typedef struct {
       char name[64];
       struct { 
           char field_name[64]; 
           char field_type[32]; 
       } fields[32];
       int field_count;
   } StructInfo;

Complete Generation Example
----------------------------

C code:

.. code-block:: c

   struct Point {
       int x;
       int y;
   };
   
   int distance(struct Point p1, struct Point p2) {
       int dx = p1.x - p2.x;
       int dy = p1.y - p2.y;
       return dx * dx + dy * dy;
   }

Generated VHDL:

.. code-block:: vhdl

   -- VHDL generated by compi (readable variant)
   
   library IEEE;
   use IEEE.STD_LOGIC_1164.ALL;
   use IEEE.NUMERIC_STD.ALL;
   
   -- Struct Point as VHDL record
   type Point_t is record
     x : std_logic_vector(31 downto 0);
     y : std_logic_vector(31 downto 0);
   end record;
   
   -- Function: distance
   entity distance is
     port (
       clk   : in  std_logic;
       reset : in  std_logic;
       p1 : in Point_t;
       p2 : in Point_t;
       result : out std_logic_vector(31 downto 0)
     );
   end entity;
   
   architecture behavioral of distance is
     signal dx : std_logic_vector(31 downto 0);
     signal dy : std_logic_vector(31 downto 0);
   begin
     process(clk, reset)
     begin
       if reset = '1' then
         -- Reset logic (user-defined)
       elsif rising_edge(clk) then
         dx <= unsigned(p1.x) - unsigned(p2.x);
         dy <= unsigned(p1.y) - unsigned(p2.y);
         result <= unsigned(dx) * unsigned(dx) + unsigned(dy) * unsigned(dy);
       end if;
     end process;
   end architecture;

Design Decisions
----------------

**Synchronous design:**

* All functions are clocked processes (``rising_edge(clk)``)
* Enables synthesis to FPGA/ASIC
* Every function has ``clk`` and ``reset`` ports

**Type conversions:**

* Extensive use of ``unsigned()`` wrapping for arithmetic
* ``to_unsigned()`` for numeric literals
* ``to_signed()`` for negative literals
* Ensures type safety in VHDL

**Operator normalization:**

* C ``==`` → VHDL ``=``
* C ``!=`` → VHDL ``/=``
* C ``&&`` → VHDL ``and``
* C ``||`` → VHDL ``or``

**Array indexing:**

* C ``arr[i]`` → VHDL ``arr(i)``
* VHDL uses parentheses for array subscripting

**Struct field flattening:**

* Parser converts ``point.x`` → ``point__x``
* Code generator converts ``point__x`` → ``point.x`` for VHDL

**For loop transformation:**

* For loops rewritten as while loops
* Initialization emitted before loop
* Increment emitted at end of loop body

Limitations
-----------

**Type system:**

* No true floating-point arithmetic (uses bit vectors)
* No string support
* No pointer arithmetic
* Limited type checking

**Control flow:**

* No switch statements
* No do-while loops
* No goto statements
* Break/continue only in loops

**Expressions:**

* No short-circuit evaluation optimization
* No operator overloading
* No function calls (each function is independent entity)

**Hardware semantics:**

* Synchronous design only (no asynchronous logic)
* Single clock domain
* No memory inference (registers only)
* No pipelining

Summary
-------

The VHDL code generator:

* Traverses the AST and emits synthesizable VHDL
* Maps C functions to VHDL entities with clocked processes
* Converts C types to VHDL types (``int`` → ``std_logic_vector(31 downto 0)``)
* Handles structs as VHDL records
* Supports arrays with VHDL array types
* Translates control flow to VHDL equivalents
* Performs extensive type conversions for VHDL compatibility

The implementation prioritizes **synthesizable output** and **hardware semantics** over direct C-to-VHDL translation, producing functionally equivalent but synchronous, clocked implementations of C programs.
