#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include "codegen_vhdl.h"
#include "symbol_structs.h"
#include "symbol_arrays.h"
#include "utils.h"
#include "parse_expression.h"

// Forward declarations for helper
static void generate_vhdl_node(ASTNode* node, FILE* output);

void generate_vhdl(ASTNode* node, FILE* output) {
    generate_vhdl_node(node, output);
}

// Implementation moved from parse.c (verbatim logic preserved)
static void generate_vhdl_node(ASTNode* node, FILE* output) {
    char* result_vhdl_type = "std_logic_vector(31 downto 0)"; // default
    if (!node) return;
    switch (node->type) {
        case NODE_PROGRAM: {
            fprintf(output, "-- VHDL generated by compi\n\n");
            fprintf(output, "library IEEE;\n");
            fprintf(output, "use IEEE.STD_LOGIC_1164.ALL;\n");
            fprintf(output, "use IEEE.NUMERIC_STD.ALL;\n\n");
            for (int s = 0; s < g_struct_count; s++) {
                StructInfo *si = &g_structs[s];
                fprintf(output, "-- Struct %s as VHDL record\n", si->name);
                fprintf(output, "type %s_t is record\n", si->name);
                for (int f = 0; f < si->field_count; f++) {
                    fprintf(output, "  %s : %s;\n", si->fields[f].field_name, ctype_to_vhdl(si->fields[f].field_type));
                }
                fprintf(output, "end record;\n\n");
            }
            for (int i = 0; i < node->num_children; i++) generate_vhdl_node(node->children[i], output);
            break; }
        case NODE_FUNCTION_DECL: {
            fprintf(output, "-- Function: %s\n", node->value);
            fprintf(output, "entity %s is\n", node->value);
            fprintf(output, "  port (\n");
            fprintf(output, "    clk : in std_logic;\n");
            fprintf(output, "    reset : in std_logic;\n");
            ASTNode *params[128]; int pcount = 0;
            for (int i = 0; i < node->num_children; i++) {
                ASTNode *c = node->children[i];
                if (c->type == NODE_VAR_DECL) params[pcount++] = c;
            }
            for (int i = 0; i < pcount; i++) {
                ASTNode *p = params[i]; int is_struct = find_struct_index(p->token.value) >= 0;
                if (is_struct) fprintf(output, "    %s : in %s_t;\n", p->value, p->token.value);
                else fprintf(output, "    %s : in %s;\n", p->value, ctype_to_vhdl(p->token.value));
            }
            int is_struct_ret = node->token.value && find_struct_index(node->token.value) >= 0;
            if (is_struct_ret) fprintf(output, "    result : out %s_t\n", node->token.value);
            else if (node->token.value && strlen(node->token.value) > 0) { result_vhdl_type = ctype_to_vhdl(node->token.value); fprintf(output, "    result : out %s\n", result_vhdl_type);} else fprintf(output, "    result : out std_logic_vector(31 downto 0)\n");
            fprintf(output, "  );\nend entity;\n\n");
            fprintf(output, "architecture behavioral of %s is\n", node->value);
            for (int i = 0; i < node->num_children; i++) {
                ASTNode *child = node->children[i];
                if (child->type == NODE_STATEMENT) {
                    for (int j = 0; j < child->num_children; j++) {
                        ASTNode *stmt_child = child->children[j];
                        if (stmt_child->type == NODE_VAR_DECL) {
                            if (find_struct_index(stmt_child->token.value) >= 0) { fprintf(output, "  signal %s : %s_t;\n", stmt_child->value, stmt_child->token.value); continue; }
                            char *arr_bracket = stmt_child->value ? strchr(stmt_child->value, '[') : NULL;
                            if (arr_bracket) {
                                int name_len = arr_bracket - stmt_child->value; char arr_name[64] = {0}; strncpy(arr_name, stmt_child->value, name_len);
                                char arr_size[32] = {0}; const char *size_start = arr_bracket + 1; const char *size_end = strchr(size_start, ']');
                                if (size_end && size_end > size_start) {
                                    strncpy(arr_size, size_start, size_end - size_start);
                                    const char *vhdl_elem_type = ctype_to_vhdl(stmt_child->token.value);
                                    fprintf(output, "  type %s_type is array (0 to %d) of %s;\n", arr_name, atoi(arr_size)-1, vhdl_elem_type);
                                    fprintf(output, "  signal %s : %s_type;\n", arr_name, arr_name);
                                    if (stmt_child->num_children > 0 && stmt_child->children[0]->value && strcmp(stmt_child->children[0]->value, "array_init") == 0) {
                                        ASTNode *init_list = stmt_child->children[0];
                                        fprintf(output, "  -- Array initialization\n");
                                        fprintf(output, "  constant %s_init : %s_type := (", arr_name, arr_name);
                                        for (int k = 0; k < init_list->num_children; k++) {
                                            const char *val = init_list->children[k]->value;
                                            if (strcmp(stmt_child->token.value, "int") == 0) {
                                                char bitstr[40] = {0}; int num = atoi(val); for (int b = 31; b >= 0; b--) bitstr[31-b] = ((num >> b) & 1) ? '1' : '0'; bitstr[32] = '\0';
                                                fprintf(output, "\"%s\"%s", bitstr, (k < init_list->num_children - 1) ? ", " : "");
                                            } else if (strcmp(stmt_child->token.value, "float") == 0 || strcmp(stmt_child->token.value, "double") == 0) {
                                                fprintf(output, "%s%s", val, (k < init_list->num_children - 1) ? ", " : "");
                                            } else if (strcmp(stmt_child->token.value, "char") == 0) {
                                                fprintf(output, "'%s'%s", val, (k < init_list->num_children - 1) ? ", " : "");
                                            } else { fprintf(output, "%s%s", val, (k < init_list->num_children - 1) ? ", " : ""); }
                                        }
                                        fprintf(output, ");\n");
                                        fprintf(output, "  signal %s : %s_type := %s_init;\n", arr_name, arr_name, arr_name);
                                    }
                                }
                            } else if (strcmp(stmt_child->value, "result") == 0) {
                                fprintf(output, "  signal internal_%s : %s;\n", stmt_child->value, ctype_to_vhdl(stmt_child->token.value));
                            } else {
                                fprintf(output, "  signal %s : %s;\n", stmt_child->value, ctype_to_vhdl(stmt_child->token.value));
                            }
                        }
                        if (stmt_child->type == NODE_FOR_STATEMENT) {
                            for (int f = 0; f < stmt_child->num_children; f++) {
                                ASTNode *for_child = stmt_child->children[f];
                                if (for_child->type == NODE_VAR_DECL) {
                                    char *arr_br = for_child->value ? strchr(for_child->value, '[') : NULL;
                                    if (arr_br) {
                                        int name_len = arr_br - for_child->value; char arr_name[64]={0}; strncpy(arr_name, for_child->value, name_len);
                                        char arr_size[32]={0}; const char *size_start = arr_br+1; const char *size_end = strchr(size_start, ']');
                                        if (size_end && size_end>size_start) { strncpy(arr_size, size_start, size_end-size_start); const char *vhdl_elem_type = ctype_to_vhdl(for_child->token.value); fprintf(output, "  type %s_type is array (0 to %d) of %s;\n", arr_name, atoi(arr_size)-1, vhdl_elem_type); fprintf(output, "  signal %s : %s_type;\n", arr_name, arr_name); }
                                    } else { fprintf(output, "  signal %s : %s;\n", for_child->value, ctype_to_vhdl(for_child->token.value)); }
                                }
                            }
                        }
                    }
                }
            }
            fprintf(output, "begin\n  process(clk, reset)\n  begin\n    if reset = '1' then\n      -- Reset logic\n    elsif rising_edge(clk) then\n");
            for (int i = 0; i < node->num_children; i++) {
                ASTNode *child = node->children[i]; if (child->type == NODE_STATEMENT) generate_vhdl_node(child, output);
            }
            fprintf(output, "    end if;\n  end process;\nend architecture;\n\n");
            break; }
        case NODE_STATEMENT: {
            for (int i = 0; i < node->num_children; i++) {
                ASTNode *child = node->children[i];
                if (child->type == NODE_VAR_DECL) {
                    char *arr_bracket = child->value ? strchr(child->value, '[') : NULL; int struct_idx = find_struct_index(child->token.value);
                    if (child->num_children > 0 && !arr_bracket && struct_idx >= 0) {
                        ASTNode *init = child->children[0]; if (init && init->value && strcmp(init->value, "struct_init") == 0) {
                            for (int f = 0; f < g_structs[struct_idx].field_count; f++) {
                                const char *field = g_structs[struct_idx].fields[f].field_name; const char *val = (f < init->num_children) ? init->children[f]->value : "0";
                                if (strcmp(g_structs[struct_idx].fields[f].field_type, "int") == 0) {
                                    if (isdigit(val[0]) || (val[0] == '-' && isdigit(val[1]))) fprintf(output, "      %s.%s <= to_unsigned(%s, 32);\n", child->value, field, val);
                                    else fprintf(output, "      %s.%s <= %s;\n", child->value, field, val);
                                } else { fprintf(output, "      %s.%s <= %s;\n", child->value, field, val); }
                            }
                        } else { fprintf(output, "      %s <= ", child->value ? child->value : "unknown"); generate_vhdl_node(init, output); fprintf(output, ";\n"); }
                    } else if (child->num_children > 0 && !arr_bracket) {
                        ASTNode *init = child->children[0]; fprintf(output, "      %s <= ", child->value ? child->value : "unknown"); generate_vhdl_node(init, output); fprintf(output, ";\n");
                    }
                }
                if (child->type == NODE_ASSIGNMENT) {
                    if (child->num_children == 2) {
                        ASTNode *lhs = child->children[0]; ASTNode *rhs = child->children[1];
                        if (lhs->value && strchr(lhs->value, '[')) {
                            char arr_name[64] = {0}; char arr_idx[64] = {0}; const char *lbr = strchr(lhs->value, '[');
                            if (lbr) { int name_len = lbr - lhs->value; strncpy(arr_name, lhs->value, name_len); const char *idx_start = lbr + 1; const char *idx_end = strchr(idx_start, ']'); if (idx_end && idx_end > idx_start) { strncpy(arr_idx, idx_start, idx_end - idx_start); fprintf(output, "      %s(%s) <= ", arr_name, arr_idx); generate_vhdl_node(rhs, output); fprintf(output, ";\n"); } else fprintf(output, "      -- Invalid array index\n"); }
                        } else { fprintf(output, "      "); generate_vhdl_node(lhs, output); fprintf(output, " <= "); generate_vhdl_node(rhs, output); fprintf(output, ";\n"); }
                    }
                }
                if (child->type == NODE_IF_STATEMENT || child->type == NODE_WHILE_STATEMENT || child->type == NODE_FOR_STATEMENT || child->type == NODE_BREAK_STATEMENT || child->type == NODE_CONTINUE_STATEMENT) generate_vhdl_node(child, output);
                if (child->type == NODE_EXPRESSION) {
                    int is_struct_ret = 0; const char* struct_ret_name = NULL; if (node->parent && node->parent->type == NODE_FUNCTION_DECL) { struct_ret_name = node->parent->token.value; is_struct_ret = struct_ret_name && find_struct_index(struct_ret_name) >= 0; }
                    int plain_ident = 1; if (child->value) { for (const char *p = child->value; *p; ++p) { if (*p == '[' || *p == ']' || *p == '.') { plain_ident = 0; break; } } if (strstr(child->value, "__")) { plain_ident = 0; } } else plain_ident = 0;
                    if (is_struct_ret && child->value && plain_ident) { int sidx = find_struct_index(struct_ret_name); if (sidx >= 0) { for (int f = 0; f < g_structs[sidx].field_count; f++) fprintf(output, "      result.%s <= %s.%s;\n", g_structs[sidx].fields[f].field_name, child->value, g_structs[sidx].fields[f].field_name); } }
                    else { fprintf(output, "      result <= "); if (child->value && child->value[0] == '-' && strlen(child->value) > 1) { if (isalpha(child->value[1]) || child->value[1] == '_') fprintf(output, "-unsigned(%s)", child->value + 1); else fprintf(output, "to_signed(%s, 32)", child->value); } else generate_vhdl_node(child, output); fprintf(output, ";\n"); }
                }
                if (child->type == NODE_BINARY_EXPR || child->type == NODE_BINARY_OP) { fprintf(output, "      result <= "); generate_vhdl_node(child, output); fprintf(output, ";\n"); }
            }
            break; }
        case NODE_WHILE_STATEMENT: {
            ASTNode *cond = node->children[0]; fprintf(output, "      while ");
            if (cond->type == NODE_BINARY_EXPR) {
                const char *cop = cond->value; int is_bool = (strcmp(cop, "==") == 0 || strcmp(cop, "!=") == 0 || strcmp(cop, "<") == 0 || strcmp(cop, "<=") == 0 || strcmp(cop, ">") == 0 || strcmp(cop, ">=") == 0 || strcmp(cop, "&&") == 0 || strcmp(cop, "||") == 0);
                if (is_bool) generate_vhdl_node(cond, output); else { fprintf(output, "unsigned("); generate_vhdl_node(cond, output); fprintf(output, ") /= 0"); }
            } else if (cond->type == NODE_BINARY_OP) generate_vhdl_node(cond, output);
            else if (cond->type == NODE_EXPRESSION && cond->value) fprintf(output, "unsigned(%s) /= 0", cond->value);
            else fprintf(output, "(%s)", cond->value ? cond->value : "false");
            fprintf(output, " loop\n"); for (int j = 1; j < node->num_children; j++) generate_vhdl_node(node->children[j], output); fprintf(output, "      end loop;\n"); break; }
        case NODE_FOR_STATEMENT: {
            if (node->num_children == 0) break;
            int cond_index = 0;
            ASTNode *first = node->children[0];
            // Support legacy AST where init may be wrapped in STATEMENT
            if (first->type == NODE_STATEMENT && first->num_children == 1 &&
                (first->children[0]->type == NODE_VAR_DECL || first->children[0]->type == NODE_ASSIGNMENT)) {
                first = first->children[0];
            }
            if (first->type == NODE_ASSIGNMENT || first->type == NODE_VAR_DECL) {
                // Emit initializer once before translating to while
                if (first->type == NODE_ASSIGNMENT && first->num_children == 2) {
                    ASTNode *lhs = first->children[0];
                    ASTNode *rhs = first->children[1];
                    fprintf(output, "      ");
                    if (lhs->value && strchr(lhs->value, '[')) {
                        char arr_name[64]={0}; char arr_idx[64]={0}; const char *lbr=strchr(lhs->value,'[');
                        if (lbr){
                            int name_len=lbr-lhs->value; strncpy(arr_name,lhs->value,name_len);
                            const char *idx_start=lbr+1; const char *idx_end=strchr(idx_start,']');
                            if(idx_end&&idx_end>idx_start){
                                strncpy(arr_idx,idx_start,idx_end-idx_start);
                                fprintf(output, "%s(%s) <= ", arr_name, arr_idx);
                                generate_vhdl_node(rhs, output);
                                fprintf(output, ";\n");
                            }
                        }
                    } else {
                        fprintf(output, "%s <= ", lhs->value ? lhs->value : "unknown");
                        generate_vhdl_node(rhs, output);
                        fprintf(output, ";\n");
                    }
                } else if (first->type == NODE_VAR_DECL) {
                    if (first->num_children > 0) {
                        ASTNode *init = first->children[0];
                        fprintf(output, "      %s <= ", first->value ? first->value : "unknown");
                        generate_vhdl_node(init, output);
                        fprintf(output, ";\n");
                    }
                }
                cond_index = 1; // condition follows initializer
            }
            if (cond_index >= node->num_children) break;
            ASTNode *cond = node->children[cond_index];
            int incr_index = node->num_children - 1;
            ASTNode *incr = NULL;
            if (node->children[incr_index]->type == NODE_ASSIGNMENT && incr_index != cond_index) incr = node->children[incr_index]; else incr_index = -1;
            fprintf(output, "      while ");
            if (cond->type == NODE_BINARY_EXPR) { const char *cop = cond->value; int is_bool = (strcmp(cop, "==") == 0 || strcmp(cop, "!=") == 0 || strcmp(cop, "<") == 0 || strcmp(cop, "<=") == 0 || strcmp(cop, ">") == 0 || strcmp(cop, ">=") == 0 || strcmp(cop, "&&") == 0 || strcmp(cop, "||") == 0); if (is_bool) generate_vhdl_node(cond, output); else { fprintf(output, "unsigned("); generate_vhdl_node(cond, output); fprintf(output, ") /= 0"); } }
            else if (cond->type == NODE_BINARY_OP) generate_vhdl_node(cond, output);
            else if (cond->type == NODE_EXPRESSION && cond->value) fprintf(output, "unsigned(%s) /= 0", cond->value);
            else fprintf(output, "( %s )", cond->value ? cond->value : "false");
            fprintf(output, " loop\n");
            for (int j = cond_index + 1; j < node->num_children; j++) { if (j == incr_index) continue; generate_vhdl_node(node->children[j], output); }
            if (incr && incr->num_children == 2) {
                ASTNode *lhs = incr->children[0];
                ASTNode *rhs = incr->children[1];
                fprintf(output, "        ");
                if (lhs->value && strchr(lhs->value, '[')) {
                    char arr_name[64]={0};
                    char arr_idx[64]={0};
                    const char *lbr=strchr(lhs->value,'[');
                    if (lbr){
                        int name_len=lbr-lhs->value;
                        strncpy(arr_name,lhs->value,name_len);
                        const char *idx_start=lbr+1;
                        const char *idx_end=strchr(idx_start,']');
                        if(idx_end&&idx_end>idx_start){
                            strncpy(arr_idx,idx_start,idx_end-idx_start);
                            fprintf(output, "%s(%s) <= ", arr_name, arr_idx);
                            generate_vhdl_node(rhs, output);
                            fprintf(output, ";\n");
                        }
                    }
                } else {
                    fprintf(output, "%s <= ", lhs->value ? lhs->value : "unknown");
                    generate_vhdl_node(rhs, output);
                    fprintf(output, ";\n");
                }
            }
            fprintf(output, "      end loop;\n");
            break; }
        case NODE_BREAK_STATEMENT: fprintf(output, "      exit;\n"); break;
        case NODE_CONTINUE_STATEMENT: fprintf(output, "      next;\n"); break;
        case NODE_BINARY_EXPR: {
            const char *op = node->value; if (strcmp(op, "==") == 0) op = "="; else if (strcmp(op, "!=") == 0) op = "/="; ASTNode *left = node->children[0]; ASTNode *right = node->children[1];
            if (strcmp(op, "&&") == 0 || strcmp(op, "||") == 0) {
                int left_is_bool = 0; if (left->type == NODE_BINARY_EXPR && left->value) { const char *lop = left->value; if (strcmp(lop, "==") == 0 || strcmp(lop, "!=") == 0 || strcmp(lop, "<") == 0 || strcmp(lop, "<=") == 0 || strcmp(lop, ">") == 0 || strcmp(lop, ">=") == 0 || strcmp(lop, "&&") == 0 || strcmp(lop, "||") == 0) left_is_bool = 1; }
                int right_is_bool = 0; if (right->type == NODE_BINARY_EXPR && right->value) { const char *rop = right->value; if (strcmp(rop, "==") == 0 || strcmp(rop, "!=") == 0 || strcmp(rop, "<") == 0 || strcmp(rop, "<=") == 0 || strcmp(rop, ">") == 0 || strcmp(rop, ">=") == 0 || strcmp(rop, "&&") == 0 || strcmp(rop, "||") == 0) right_is_bool = 1; }
                fprintf(output, "("); if (left_is_bool) { fprintf(output, "("); generate_vhdl_node(left, output); fprintf(output, ")"); } else { fprintf(output, "unsigned("); generate_vhdl_node(left, output); fprintf(output, ") /= 0"); }
                fprintf(output, "%s", strcmp(op, "&&") == 0 ? " and " : " or ");
                if (right_is_bool) { fprintf(output, "("); generate_vhdl_node(right, output); fprintf(output, ")"); } else { fprintf(output, "unsigned("); generate_vhdl_node(right, output); fprintf(output, ") /= 0"); }
                fprintf(output, ")"); break;
            }
            if (strcmp(op, "=") == 0 || strcmp(op, "/=") == 0 || strcmp(op, "<") == 0 || strcmp(op, "<=") == 0 || strcmp(op, ">") == 0 || strcmp(op, ">=") == 0) {
                if (left->type == NODE_EXPRESSION) { if (is_negative_literal(left->value)) fprintf(output, "to_signed(%s, 32)", left->value); else { int is_num = 1; const char *p = left->value; if (!*p) is_num = 0; while (*p) { if (!isdigit(*p) && *p != '.') { is_num = 0; break; } p++; } if (is_num) fprintf(output, "to_unsigned(%s, 32)", left->value); else fprintf(output, "unsigned(%s)", left->value); } }
                else { fprintf(output, "unsigned("); generate_vhdl_node(left, output); fprintf(output, ")"); }
                fprintf(output, " %s ", op);
                if (right->type == NODE_EXPRESSION) { if (is_negative_literal(right->value)) fprintf(output, "to_signed(%s, 32)", right->value); else { int is_num = 1; const char *p = right->value; if (!*p) is_num = 0; while (*p) { if (!isdigit(*p) && *p != '.') { is_num = 0; break; } p++; } if (is_num) fprintf(output, "to_unsigned(%s, 32)", right->value); else fprintf(output, "unsigned(%s)", right->value); } }
                else { fprintf(output, "unsigned("); generate_vhdl_node(right, output); fprintf(output, ")"); }
            } else if (strcmp(op, "&") == 0) { fprintf(output, "unsigned("); generate_vhdl_node(left, output); fprintf(output, ") and unsigned("); generate_vhdl_node(right, output); fprintf(output, ")"); }
            else if (strcmp(op, "|") == 0) { fprintf(output, "unsigned("); generate_vhdl_node(left, output); fprintf(output, ") or unsigned("); generate_vhdl_node(right, output); fprintf(output, ")"); }
            else if (strcmp(op, "^") == 0) { fprintf(output, "unsigned("); generate_vhdl_node(left, output); fprintf(output, ") xor unsigned("); generate_vhdl_node(right, output); fprintf(output, ")"); }
            else if (strcmp(op, "<<") == 0) { fprintf(output, "shift_left(unsigned("); generate_vhdl_node(left, output); fprintf(output, "), to_integer(unsigned("); generate_vhdl_node(right, output); fprintf(output, ")))" ); }
            else if (strcmp(op, ">>") == 0) { fprintf(output, "shift_right(unsigned("); generate_vhdl_node(left, output); fprintf(output, "), to_integer(unsigned("); generate_vhdl_node(right, output); fprintf(output, ")))" ); }
            else { generate_vhdl_node(left, output); fprintf(output, " %s ", op); generate_vhdl_node(right, output); }
            break; }
        case NODE_IF_STATEMENT: {
            ASTNode *cond = node->children[0]; fprintf(output, "      if ");
            if (cond->type == NODE_BINARY_EXPR) { const char *cop = cond->value; int is_bool = (strcmp(cop, "==") == 0 || strcmp(cop, "!=") == 0 || strcmp(cop, "<") == 0 || strcmp(cop, "<=") == 0 || strcmp(cop, ">") == 0 || strcmp(cop, ">=") == 0 || strcmp(cop, "&&") == 0 || strcmp(cop, "||") == 0); if (is_bool) generate_vhdl_node(cond, output); else { fprintf(output, "unsigned("); generate_vhdl_node(cond, output); fprintf(output, ") /= 0"); } fprintf(output, " then\n"); }
            else if (cond->type == NODE_BINARY_OP) { generate_vhdl_node(cond, output); fprintf(output, " then\n"); }
            else if (cond->type == NODE_EXPRESSION && cond->value) fprintf(output, "unsigned(%s) /= 0 then\n", cond->value);
            else fprintf(output, "(%s) then\n", cond->value ? cond->value : "false");
            for (int j = 1; j < node->num_children; j++) {
                ASTNode *branch = node->children[j];
                if (branch->type == NODE_ELSE_IF_STATEMENT) {
                    ASTNode *elseif_cond = branch->children[0]; fprintf(output, "      elsif ");
                    if (elseif_cond->type == NODE_BINARY_EXPR) { const char *ecop = elseif_cond->value; int elseif_is_bool = (strcmp(ecop, "==") == 0 || strcmp(ecop, "!=") == 0 || strcmp(ecop, "<") == 0 || strcmp(ecop, "<=") == 0 || strcmp(ecop, ">") == 0 || strcmp(ecop, ">=") == 0 || strcmp(ecop, "&&") == 0 || strcmp(ecop, "||") == 0); if (elseif_is_bool) generate_vhdl_node(elseif_cond, output); else { fprintf(output, "unsigned("); generate_vhdl_node(elseif_cond, output); fprintf(output, ") /= 0"); } fprintf(output, " then\n"); }
                    else if (elseif_cond->type == NODE_BINARY_OP) { generate_vhdl_node(elseif_cond, output); fprintf(output, " then\n"); }
                    else if (elseif_cond->type == NODE_EXPRESSION && elseif_cond->value) fprintf(output, "unsigned(%s) /= 0 then\n", elseif_cond->value);
                    else fprintf(output, "(%s) then\n", elseif_cond->value ? elseif_cond->value : "false");
                    for (int k = 1; k < branch->num_children; k++) generate_vhdl_node(branch->children[k], output);
                } else if (branch->type == NODE_ELSE_STATEMENT) { fprintf(output, "      else\n"); for (int k = 0; k < branch->num_children; k++) generate_vhdl_node(branch->children[k], output); }
                else generate_vhdl_node(branch, output);
            }
            fprintf(output, "      end if;\n"); break; }
        case NODE_EXPRESSION: {
            if (node->value && strchr(node->value, '[')) { char arr_name[64]={0}; char arr_idx[64]={0}; const char *lbr=strchr(node->value,'['); if (lbr){int name_len=lbr-node->value;strncpy(arr_name,node->value,name_len);const char *idx_start=lbr+1;const char *idx_end=strchr(idx_start,']'); if(idx_end&&idx_end>idx_start){strncpy(arr_idx,idx_start,idx_end-idx_start); fprintf(output, "%s(%s)", arr_name, arr_idx);} else fprintf(output, "-- Invalid array index"); } }
            else if (is_negative_literal(node->value)) { if (isalpha(node->value[1]) || node->value[1] == '_') fprintf(output, "-unsigned(%s)", node->value + 1); else fprintf(output, "to_signed(%s, 32)", node->value); }
            else { if (node->value && strstr(node->value, "__")) { char buf[256]; strncpy(buf, node->value, sizeof(buf)-1); buf[sizeof(buf)-1]='\0'; for (char *p = buf; *p; p++) { if (*p=='_' && *(p+1)=='_') { *p='.'; memmove(p+1, p+2, strlen(p+2)+1); } } fprintf(output, "%s", buf); } else fprintf(output, "%s", node->value ? node->value : "unknown"); }
            break; }
        case NODE_BINARY_OP: {
            if (node->value && strcmp(node->value, "!") == 0 && node->num_children == 1) { ASTNode *inner = node->children[0]; int inner_is_bool = 0; if (inner->type == NODE_BINARY_EXPR && inner->value) { const char *iop = inner->value; if (strcmp(iop, "==") == 0 || strcmp(iop, "!=") == 0 || strcmp(iop, "<") == 0 || strcmp(iop, "<=") == 0 || strcmp(iop, ">") == 0 || strcmp(iop, ">=") == 0 || strcmp(iop, "&&") == 0 || strcmp(iop, "||") == 0) inner_is_bool = 1; } else if (inner->type == NODE_BINARY_OP && inner->value && strcmp(inner->value, "!") == 0) inner_is_bool = 1; if (inner_is_bool) { fprintf(output, "not ("); generate_vhdl_node(inner, output); fprintf(output, ")"); } else { fprintf(output, "(unsigned("); generate_vhdl_node(inner, output); fprintf(output, ") = 0)"); } }
            else if (node->value && strcmp(node->value, "~") == 0 && node->num_children == 1) { ASTNode *inner = node->children[0]; fprintf(output, "not unsigned("); generate_vhdl_node(inner, output); fprintf(output, ")"); }
            else fprintf(output, "-- unsupported unary op");
            break; }
        default: break;
    }
}

// End of codegen_vhdl.c
